# 고민 사항

1. 특정 시간에 대한 예약이 존재하는데, 그 시간을 삭제하려 하는 경우
    - `DataIntegrityViolationException` 을 try-catch 로 처리한다.
    - delete 하고자 하는 `time_id` 와 연관되어 있는 `reservation` 이 존재하는지 확인한 뒤에 처리한다.

   두 가지의 선택지 중, 해당 SQLException 이 무결성 제약 조건을 위반할 때에만 던져지는 예외로 이해했습니다.
   삭제와 관련된 무결성 제약 조건을 위반하는 경우는 FK 와 관련된 경우밖에 없다고 생각해서 1번 방식을 선택하고자 했습니다.
   또한 2번 선택지로 결정한 경우 `schema.sql` 에 `CASCADE` 를 추가하게 된다면 서비스 코드를 또 변경하게 될텐데 이러한 경우 간접적으로 DB 에 의존 되어 있는 코드가 아닌가 하는 의문이
   들었습니다.
   그래서 결과적으로 1번 방식을 선택하게 되었습니다. 그러나 이 방식이 예상치 못한 다른 상황까지 처리해버려서 저희가 의도하지 않은 방식으로 동작하게 될 우려는 없는지, 잘 처리한 것인지 궁금합니다.

2. reservation_time 에 중복된 start_at 을 저장하려 하는 경우
   우선 reservation_time 테이블 정의 시에 start_at 을 중복되지 않도록 UNIQUE KEY 로 지정해 주었습니다.
    - `DataIntegrityViolationException` 을 try-catch 로 처리한다.
    - 해당 start_at 이 이미 저장되어 있는지 확인한다.

   두 가지의 선택지 중, 저희는 두번째 선택지를 고르고자 했는데 중복의 경우에는 비지니스 로직에 가깝다고 생각하여 데이터베이스에서 발생하는 예외를 잡아 처리하기보다는 직접 쿼리를 통해 확인하는 것이 적절하다고
   생각했습니다.
   코드로 중복 여부를 작성하여야 코드를 읽는 사람의 입장에서 해당 도메인에서는 어떤 규칙을 정의하는지 파악하기 용이하며, Exception 으로 캐치하기에는 데이터베이스에 삽입 과정에서는 Exception 이
   발생하는 상황이 너무 광범위하지 않을까 하는 우려가 있었습니다. DELETE 를 수정하지 않은 이유는 DELETE 과정에서 `DataIntegrityViolationException` 가 발생하는 상황은 외래키
   제약 조건이 어겨질 때 밖에 없기 때문에 상대적으로 Exception 의 종류가 광범위하지 않고 특정된다고 생각했습니다.

3. AvailableReservationTime 도메인 클래스 분리 여부에 대한 고민
   현재 reservation_time 테이블에서 예약 가능 시간 정보를 조회할 때, 단순히 시간만을 사용하는 경우(ReservationTime)와 더불어, 
   특정 날짜/테마 조합에 따라 해당 시간이 이미 예약되었는지 여부까지 함께 판단해야 하는 경우(AvailableReservationTime)가 존재합니다.
   이때 AvailableReservationTime은 ReservationTime의 속성(startAt 등)을 대부분 포함하고 있으며, 여기에 예약 여부(already_booked) 속성만 추가된 형태입니다.
   - ReservationTime을 상속받은 AvailableReservationTime 클래스를 만들어 사용하는 방식
   - ReservationTime을 내부에 필드로 갖는 조합 방식 (Composition)
   - 현재처럼 별도의 클래스(AvailableReservationTime)로 독립적으로 사용하는 방
   
   저희의 선택: 별도의 클래스로 유지 (합치지 않음, 상속/조합도 사용하지 않음)
   현재 시점에서는 AvailableReservationTime이 예약 가능 여부를 함께 나타내는 특수한 도메인으로, 컨텍스트가 기존 ReservationTime과 분리된다고 판단했습니다. 
   ReservationTime은 단순히 시간 정보만을 표현하는 기본 도메인이고, AvailableReservationTime은 특정 날짜와 테마에 따라 해당 시간이 예약되었는지를 판단하는 조회용 결과 도메인에 가까운 성격을 가집니다.
   따라서 상속이나 조합을 사용하는 것은 구조적으로 과하게 추상화된 설계가 될 수 있으며, 현재처럼 목적에 맞게 독립된 클래스를 유지하는 것이 가독성과 의도를 명확히 드러내는 데에 더 적합하다고 판단했습니다.
   특히 already_booked의 유무에 따라 도메인의 의미 자체가 달라지기 때문에, 이를 하나의 도메인으로 뭉뚱그리는 것보다는 분리해서 각각 명확한 책임을 가지게 하는 설계가 유지보수와 코드 해석에 유리하다고 생각했습니다.

---

1. 정상 작동

- [x] 시간 관리, 예약 관리 API가 적절한 응답을 하도록 변경

2. 예외 처리

- [x] 시간 생성 시 시작 시간이 유효하지 않은 값인 경우
- [x] 예약 생성 시 예약자명 / 날짜 / 시간에 유효하지 않은 값이 입력 되었을 때
- [x] 특정 시간에 대한 예약이 존재하는데, 그 시간을 삭제하려 할 때
- [x] 같은 날짜와 시각에 대한 예약이 존재하는데 등록하고자 할 때
- [x] 지나간 날짜와 시각에 대한 예약을 등록하고자 할 때
- [x] reservation_time 의 start_at 은 중복이 아니어야 한다.
- [x] theme 의 name 은 중복이 아니어야 한다.

3. 테마 요구사항

- [x] 테마 도메인 및 테이블 세팅하기
- [x] 관리자의 테마 관리 기능 구현
    - [x] 테마 조회
    - [x] 테마 추가
    - [x] 테마 삭제
- [x] 관리자가 예약 정보 등록 시에 테마 선택하도록 구현

4. 사용자 예약 요구사항

- [x] 테마 전체 조회 기능 구현
    - [x] 날짜를 선택했을 때 테마를 선택할 수 있도록 js 파일 수정
- [x] 예약 가능한 날짜 전체 조회 기능 구현
    - [x] 날짜와 테마에 따라 가능한 예약 시간들을 조회하는 API 추가
    - [x] 예약 시각들을 보여주는 js 파일 수정

5. 인기 테마 요구사항

- [x] 최근 일주일 기준 예약이 많은 테마 10개를 확인하는 API 추가
- [x] `/` 요청 시 `/templates/index.html` 을 응답하도록 한다

### 추후 고려 사항

- FakeDao 를 사용하니 잡을 수 없는 예외(`DataIntegrityViolationException`) 가 있어 테스트 불가
