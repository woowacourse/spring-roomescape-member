# 고민 사항

### 1. 특정 시간에 대한 예약이 존재하는데, 그 시간을 삭제하려 하는 경우

- **대안 1**: `DataIntegrityViolationException`을 try-catch로 처리한다.
- **대안 2**: 삭제하고자 하는 `time_id`와 연관된 `reservation`이 존재하는지 확인한 뒤에 처리한다.

#### 선택: 대안 1

- 해당 SQLException이 무결성 제약 조건을 위반할 때에만 던져지는 예외로 이해했습니다.
- 삭제와 관련된 무결성 제약 조건을 위반하는 경우는 FK와 관련된 경우밖에 없다고 생각해서 **대안 1** 방식을 선택하고자 했습니다.
- **대안 2**로 결정한 경우, `schema.sql`에 `CASCADE`를 추가하게 된다면 서비스 코드가 또 변경될 텐데, 이러한 경우 간접적으로 DB에 의존되는 코드가 아닌가 하는 의문이 들었습니다.
- 결과적으로 **대안 1** 방식을 선택하게 되었습니다. 그러나 이 방식이 예상치 못한 다른 상황까지 처리해버려서 저희가 의도하지 않은 방식으로 동작할 우려는 없는지, 잘 처리한 것인지 궁금합니다.

---

### 2. reservation_time에 중복된 start_at을 저장하려 하는 경우

- **대안 1**: `DataIntegrityViolationException`을 try-catch로 처리한다.
- **대안 2**: 해당 start_at이 이미 저장되어 있는지 확인한다.

#### 선택: 대안 2

- 중복의 경우 비즈니스 로직에 가깝다고 생각하여 데이터베이스에서 발생하는 예외를 잡아 처리하기보다는 **대안 2**가 적절하다고 생각했습니다.
- 코드로 중복 여부를 작성해야 코드를 읽는 사람 입장에서 해당 도메인에서 어떤 규칙을 정의하는지 파악하기 용이하며, 예외로 캐치하기에는 데이터베이스 삽입 과정에서 발생하는 예외가 너무 광범위하지 않을까 하는 우려가 있었습니다.
- `DELETE`를 수정하지 않은 이유는 `DataIntegrityViolationException`가 발생하는 상황은 외래키 제약 조건이 어겨질 때밖에 없기 때문에 상대적으로 예외의 종류가 광범위하지 않고 특정된다고 생각했습니다.

---

### 3. AvailableReservationTime 도메인 클래스 분리 여부에 대한 고민

현재 `reservation_time` 테이블에서 예약 가능 시간 정보를 조회할 때, 단순히 시간만을 사용하는 경우(ReservationTime)와 특정 날짜/테마 조합에 따라 해당 시간이 이미 예약되었는지 여부까지 함께 판단해야 하는 경우(AvailableReservationTime)가 존재합니다. 이때 `AvailableReservationTime`은 `ReservationTime`의 속성(startAt 등)을 대부분 포함하고 있으며, 여기에 예약 여부(`already_booked`) 속성만 추가된 형태입니다.

#### 대안들
- `ReservationTime`을 상속받은 `AvailableReservationTime` 클래스를 만들어 사용하는 방식
- `ReservationTime`을 내부에 필드로 갖는 조합 방식 (Composition)
- 현재처럼 별도의 클래스(`AvailableReservationTime`)로 독립적으로 사용하는 방식

#### 선택: 별도의 클래스로 유지 (합치지 않음, 상속/조합도 사용하지 않음)

- 현재 시점에서는 `AvailableReservationTime`이 예약 가능 여부를 함께 나타내는 특수한 도메인으로, 컨텍스트가 기존 `ReservationTime`과 분리된다고 판단했습니다.
- `ReservationTime`은 단순히 시간 정보만을 표현하는 기본 도메인이고, `AvailableReservationTime`은 특정 날짜와 테마에 따라 해당 시간이 예약되었는지를 판단하는 조회용 결과 도메인에 가까운 성격을 가집니다.
- 따라서 상속이나 조합을 사용하는 것은 구조적으로 과하게 추상화된 설계가 될 수 있으며, 현재처럼 목적에 맞게 독립된 클래스를 유지하는 것이 가독성과 의도를 명확히 드러내는 데에 더 적합하다고 판단했습니다.
- 특히 `already_booked`의 유무에 따라 도메인의 의미 자체가 달라지기 때문에, 이를 하나의 도메인으로 뭉뚱그리는 것보다는 분리해서 각각 명확한 책임을 가지게 하는 설계가 유지보수와 코드 해석에 유리하다고 생각했습니다.


---

1. 정상 작동

- [x] 시간 관리, 예약 관리 API가 적절한 응답을 하도록 변경

2. 예외 처리

- [x] 시간 생성 시 시작 시간이 유효하지 않은 값인 경우
- [x] 예약 생성 시 예약자명 / 날짜 / 시간에 유효하지 않은 값이 입력 되었을 때
- [x] 특정 시간에 대한 예약이 존재하는데, 그 시간을 삭제하려 할 때
- [x] 같은 날짜와 시각에 대한 예약이 존재하는데 등록하고자 할 때
- [x] 지나간 날짜와 시각에 대한 예약을 등록하고자 할 때
- [x] reservation_time 의 start_at 은 중복이 아니어야 한다.
- [x] theme 의 name 은 중복이 아니어야 한다.

3. 테마 요구사항

- [x] 테마 도메인 및 테이블 세팅하기
- [x] 관리자의 테마 관리 기능 구현
    - [x] 테마 조회
    - [x] 테마 추가
    - [x] 테마 삭제
- [x] 관리자가 예약 정보 등록 시에 테마 선택하도록 구현

4. 사용자 예약 요구사항

- [x] 테마 전체 조회 기능 구현
    - [x] 날짜를 선택했을 때 테마를 선택할 수 있도록 js 파일 수정
- [x] 예약 가능한 날짜 전체 조회 기능 구현
    - [x] 날짜와 테마에 따라 가능한 예약 시간들을 조회하는 API 추가
    - [x] 예약 시각들을 보여주는 js 파일 수정

5. 인기 테마 요구사항

- [x] 최근 일주일 기준 예약이 많은 테마 10개를 확인하는 API 추가
- [x] `/` 요청 시 `/templates/index.html` 을 응답하도록 한다

3. 테마 요구사항

- [x] 테마 도메인 및 테이블 세팅하기
- [ ] 관리자의 테마 관리 기능 구현
    - [x] 테마 조회
    - [x] 테마 추가
    - [x] 테마 삭제
- [x] 관리자가 예약 정보 등록 시에 테마 선택하도록 구현

### 추후 고려 사항

- FakeDao 를 사용하니 잡을 수 없는 예외(`DataIntegrityViolationException`) 가 있어 테스트 불가
